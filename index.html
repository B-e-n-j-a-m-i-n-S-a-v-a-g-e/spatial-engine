<!doctype html>
<html>
  <head>
    <meta http-equiv="origin-trial" content="AspvaSU7F1Gbpa8q9JRNRNXFF+0+77C1xkxf1hkzJCrBI7Mmt/eG25QXLBn7lfzPsgrN5next8ZtIiCeGs6R4w8AAABleyJvcmlnaW4iOiJodHRwczovL2V4b2tpdC5vcmc6NDQzIiwiZmVhdHVyZSI6IldlYlhSRGV2aWNlTTc2IiwiZXhwaXJ5IjoxNTcxMTEyNjU0LCJpc1N1YmRvbWFpbiI6dHJ1ZX0=">
    <style>
* {
  box-sizing: border-box;
}
body {
  margin: 0;
  /* background-color: #000;
  color: #F5F5F5; */
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen","Ubuntu","Cantarell","Fira Sans","Droid Sans","Helvetica Neue",sans-serif;
  font-size: 15px;
}
.body {
  display: flex;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}
.body.fullscreen .header,
.body.fullscreen .sidebar,
.body.fullscreen .tools,
.body.fullscreen .iframe-buttons
{
  display: none;
}
.body.fullscreen .iframe-wrapper {
  margin-top: 0;
}
header {
  position: absolute;
  display: flex;
  top: 0;
  left: 0;
  width: 100vw;
  height: 50px;
  background-color: #FFF;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  align-items: center;
  user-select: none;
  z-index: 1;
}
.main-selector {
  outline: none;
}
.main-selector:hover .target,
.main-selector .options .option:hover
{
  background-color: #42a5f5;
  color: #FFF;
}
.main-selector:active .target,
.main-selector.open .target,
.main-selector .options .option:active,
.main-selector .options .option.open
{
  background-color: #1e88e5;
  color: #FFF;
}
.main-selector:hover .target .icon,
.main-selector.open .target .icon
{
  filter: invert(1);
}
.main-selector .target .icon {
  width: 50px;
  height: 50px;
  margin: 0 20px;
}
.main-selector .options {
  display: flex;
  position: absolute;
  top: 50px;
  left: 0;
  width: 300px;
  background-color: #FFF;
  color: #000;
  flex-direction: column;
}
.main-selector .options .option {
  padding: 15px;
}
.main-selector:not(.open) .options {
  display: none;
}
header nav {
  display: flex;
  height: 100%;
  padding: 0 10px;
  letter-spacing: 0.9px;
  align-items: center;
}
header nav span {
  display: flex;
  height: 30px;
  padding: 10px;
  border-radius: 4px;
  align-items: center;
  text-transform: uppercase;
}
header nav.selected span {
  background-color: #5c6bc0;
  color: #FFF;
  cursor: default;
}
header nav:not(.selected):not([disabled]):hover {
  cursor: pointer;
}
header nav:not(.selected):hover span {
  background-color: #EEE;
}
header:not(.main-2) .channel-select,
header:not(.main-3) .parcel-display
{
  display: none;
}
.channel-select {
  display: flex;
  position: relative;
  align-items: center;
}
.channel-select input[type=text] {
  height: 50px;
  border-radius: 0;
}
.parcel-display {
  display: flex;
}
.channels-content {
  display: flex;
  position: absolute;
  top: 50px;
  left: 0;
  right: 0;
  flex-direction: column;
  background-color: #FFF;
}
.channels-content .a-channel {
  display: flex;
  padding: 5px;
  align-items: center;
  cursor: pointer;
}
.channels-content .a-channel:hover {
  background-color: #EEE;
}
.channels-content .a-channel:hover i {
  background-color: #000;
  color: #FFF;
}
.channels-content .a-channel i {
  display: flex;
  height: 50px;
  width: 50px;
  margin-right: 10px;
  background-color: #EEE;
  border-radius: 5px;
  font-size: 16px;
  justify-content: center;
  align-items: center;
}
.parcel-create,
.parcel-edit
{
  display: flex;
}
.parcel-create:not(.open),
.parcel-edit:not(.open)
{
  display: none;
}
.details-content h1,
.details-content h2,
.details-content h3,
.details-content h4,
.details-content h5,
.details-content h6,
.details-content p,
.details-content .multibutton
{
  margin: 15px 0;
  padding: 0 20px;
}
h1, h2, h3, h4, h5, h6, p {
  font-weight: inherit;
}
.screenshot-image {
  width: 100%;
}
.iframe-wrapper {
  position: relative;
  display: flex;
  margin-top: 50px;
  flex: 1;
  background-color: #000;
}
.tabs {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
.tabs .tab {
  display: inline-flex;
  margin: 5px 5px;
  padding: 5px 10px;
  background-color: #D8D8D8;
  border-radius: 4px;
  color: #000;
  align-items: center;
}
.tabs .tab .text {
  margin-right: 10px;
  align-items: center;
}
.tabs .tab .close-x {
  display: flex;
  width: 20px;
  height: 20px;
  background-color: #ef5350;
  color: #FFF;
  justify-content: center;
  align-items: center;
}
canvas {
  width: 100% !important;
  height: 100% !important;
  /* background-color: #f8f8f8; */
  outline: none;
}
a {
  color: #AAA;
  text-decoration: none;
}
a:hover {
  color: #42a5f5;
}
a:active {
  color: #1976d2;
}
.tools {
  display: flex;
  position: absolute;
  top: 60px;
  left: 10px;
}
.tools > .tool {
  display: flex;
  width: 30px;
  height: 30px;
  justify-content: center;
  align-items: center;
  background-color: #EEE;
  font-size: 16px;
  /* color: #000; */
  cursor: pointer;
}
.tools > .tool:hover {
  background-color: #42a5f5;
  color: #FFF;
}
.tools > .tool:active, .tools > .tool.open {
  background-color: #1e88e5;
  color: #FFF;
}
.chat {
  position: absolute;
  bottom: 30px;
  left: 0;
  width: 400px;
  display: flex;
  flex-direction: column;
  pointer-events: none;
}
.chat > .messages {
  display: flex;
  flex-direction: column;
  padding: 7px 14px;
  background-color: rgba(0, 0, 0, 0.5);
  border-radius: 8px;
  color: #FFF;
  pointer-events: all;
}
.chat > .messages:empty {
  display: none;
}
.chat > .input {
  width: 100%;
  /* background-color: transparent; */
  background-color: rgba(50, 50, 50, 0.5);
  color: #FFF;
  pointer-events: all;
}
.chat > .input:not(.open) {
  visibility: hidden;
}
.save-dialog {
  display: flex;
  flex-direction: column;
  position: absolute;
  top: 50px;
  left: 0;
  width: 300px;
  padding: 30px;
  background-color: #FFF;
}
.save-dialog:not(.open) {
  display: none;
}
.iframe-buttons {
  position: absolute;
  right: 330px;
  bottom: 30px;
}
.code-buttons {
  position: absolute;
  right: 30px;
  bottom: 30px;
  display: flex;
}
.multibutton {
  display: flex;
}
.multibutton .button:not(.first) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.multibutton .button:not(.last) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.button {
  display: inline-flex;
  margin-right: 5px;
  padding: 7px 14px;
  border: 2px solid;
  border-radius: 100px;
  color: #5c6bc0;
  font-size: 13px;
  outline: none
}
/* .button:not(:last-child) {
  margin-right: 20px;
} */
.button:not([disabled]):hover {
  background-color: #5c6bc0;
  border-color: #5c6bc0;
  color: #FFF;
  cursor: pointer;
}
.button[disabled] {
  color: #b71c1c;
}
#code-header:not(.open),
#code-button:not(.open) .opened-text,
#code-button.open .closed-text
{
  display: none;
}
.coming-soon {
  color: #ccc;
}
.coming-soon-sub {
  font-size: 10px;
  display: block;
}
.header-link {
  color: #666;
}
.code-header {
  position: absolute;
  top: 50px;
  right: 0;
  display: flex;
  align-items: center;
  width: 600px;
  height: 32px;
  padding: 5px;
  font-size: 13px;
  color: #4caf50;
  background-color: #f2f3f5;
}
.sidebar {
  /* display: flex; */
  margin-top: 50px;
  width: 300px;
  background-color: #FFF;
}
.sidebar .content-tabs, .sidebar .content-tabs .content-tab {
  background-color: #CCC;
}
.sidebar .content-tabs .content-tab {
  display: flex;
  position: relative;
  width: 50px;
  height: 50px;
  justify-content: center;
  align-items: center;
  font-size: 16px;
  color: #333;
  cursor: pointer;
}
.sidebar .content-tabs .content-tab:hover {
  background-color: #EEE;
  color: #000;
}
.sidebar .content-tabs .content-tab.open {
  background-color: #FFF;
  color: #5c6bc0;
}
.sidebar .content-tabs .content-tab .sub {
  display: flex;
  position: absolute;
  width: 100px;
  height: 50px;
  left: -100px;
  background-color: #333;
  color: #FFF;
  justify-content: center;
  align-items: center;
  visibility: hidden;
}
.sidebar .content-tabs .content-tab:hover .sub {
  visibility: visible;
}
.sidebar .content {
  flex: 1;
  overflow-y: auto;
}
.sidebar .content:not(.open) {
  display: none;
}
.site-urls-content .a-site,
.avatar-models-content .a-avatar,
.prefabs-content .a-prefab,
.inventory-content .a-file
{
  display: flex;
  position: relative;
  padding: 5px 0;
  cursor: pointer;
  overflow: hidden;
}
.site-urls-content .a-site img,
.avatar-models-content .a-avatar img,
.prefabs-content .a-prefab img,
.inventory-content .a-file i
{
  display: flex;
  width: 80px;
  height: 80px;
  margin-right: 10px;
  font-size: 50px;
  justify-content: center;
  align-items: center;
}
.site-urls-content .a-site img:not([src]),
.avatar-models-content .a-avatar img:not([src]),
.prefabs-content .a-prefab img:not([src]) {
  visibility: hidden;
}
.site-urls-content .a-site .wrap {
  flex: 1;
  overflow: hidden;
}
.site-urls-content .a-site .url {
  color: #666;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.prefabs-content .a-prefab .wrap {
  flex: 1;
  overflow: hidden;
}
.site-urls-content > .wrap {
  display: flex;
}
.site-urls-content input[type=text],
.avatar-models-content input[type=text],
.prefabs-content input[type=text]
{
  width: 100%;
  margin: 0;
  padding: 15px;
  border-radius: 0;
}
.site-urls-content .input-button {
  display: flex;
  width: 48px;
  height: 48px;
  background-color: #CCC;
  color: #333;
  justify-content: center;
  align-items: center;
  cursor: pointer;
}
.site-urls-content .input-button:hover {
  background-color: #5c6bc0;
  color: #FFF;
}
.site-urls-content .input-button:active {
  background-color: #3949ab;
  color: #FFF;
}
.site-urls-content .a-site .wrap .label {
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}
.site-urls-content .a-site .overlay,
.avatar-models-content .a-avatar .overlay,
.prefabs-content .a-prefab .overlay,
.inventory-content .a-file .overlay
{
  display: flex;
  position: absolute;
  top: -3px;
  bottom: -3px;
  left: 0;
  right: 0;
  padding: 10px;
  background-image: linear-gradient(to right, transparent, #FFF 50%);
  justify-content: flex-end;
  align-items: center;
  visibility: hidden;
}
.site-urls-content .a-site:hover .overlay,
.avatar-models-content .a-avatar:hover .overlay,
.prefabs-content .a-prefab:hover .overlay,
.inventory-content .a-file:hover .overlay
{
  visibility: visible;
}
.prefabs-content .end {
  width: 100%;
  height: 1px;
}
.selected-object-details,
.avatar-details,
/* .parcel-details, */
.placeholder-details
{
  display: none;
}
.selected-object-details.open,
.avatar-details.open,
/* .parcel-details.open, */
.selected-object-details:not(.open) + .avatar-details:not(.open) /* + .parcel-details:not(.open) */ + .placeholder-details
{
  display: block;
}
.switch-wrap {
  display: flex;
  align-items: center;
  color: #AAA;
  cursor: pointer;
  user-select: none;
  // transition: all 0.3s cubic-bezier(0, 1, 0, 1);
}
.switch {
  position: relative;
  margin-right: 5px;
  padding: 2px;
  border: 2px solid #AAA;
  border-radius: 100px;
  cursor: pointer;
  // transition: all 0.3s cubic-bezier(0, 1, 0, 1);
}
.switch::before {
  display: block;
  position: relative;
  height: 12px;
  width: 24px;
  background-color: #EEE;
  border-radius: 100px;
  content: '';
}
.switch::after {
  display: block;
  position: absolute;
  top: 2px;
  left: 2px;
  height: 12px;
  width: 12px;
  background-color: #AAA;
  border-radius: 100px;
  content: '';
  // transition: all 0.3s cubic-bezier(0, 1, 0, 1);
}
.switch-wrap.on {
  color: #5c6bc0;
}
.switch-wrap.on .switch {
  border-color: #5c6bc0;
}
/* .switch.on::before {
  background-color: #BBB;
} */
.switch-wrap.on .switch::after {
  left: 14px;
  background-color: #5c6bc0;
}
input[type=button] {
  display: block;
}
.code {
  width: 100%;
  height: 100%;
  font-family: monospace;
  font-size: 14px;
  border: 0;
  outline: none;
}
.minibuttons {
  position: relative;
}
.minibuttons button {
  position: absolute;
  bottom: 0;
}
.minibuttons button + button {
  left: 50px;
}
.user-code {
  display: none;
}
input[type=text] {
  width: 160px;
  /* margin: 0 20px; */
  padding: 7px 14px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  font-family: inherit;
  font-size: inherit;
  outline: none;
}

/* account.css */

input[type=email],
input[type=text]
{
  margin-right: 10px;
  padding: 7px 14px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  font-family: inherit;
  font-size: inherit;
  outline: none;
}

header > .login-form {
  display: flex;
  margin-left: auto;
}

body.logging-in .login-form,
header > .login-form:not(.phase-1) > .phase-1-content,
header > .login-form:not(.phase-2) > .phase-2-content,
header > .login-form:not(.phase-3) > .phase-3-content,
header > .login-form.phase-1 > .phaseless-content,
header > .login-form.phase-2 > .phaseless-content,
header > .login-form.phase-3 > .phaseless-content
{
  display: none;
}

.login-form .phase-content {
  display: flex;
  align-items: center;
}
.login-form .phase-content .login-error
{
  margin-right: 15px;
  font-weight: 600;
}
.login-form .phase-content .user-button {
  display: flex;
  height: 30px;
  margin-right: 10px;
  padding: 3px 10px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  align-items: center;
  cursor: pointer;
}
.login-form .phase-content .user-button:hover,
.login-form .phase-content .user-button.open {
  background-color: #CCC;
}
.login-form .phase-content .user-button > img {
  width: 20px;
  height: 20px;
  margin-right: 5px;
}
.login-form .phase-content .user-button > .name {
  display: flex;
  height: 100%;
  font-weight: 600;
  align-items: center;
}
.login-form .phase-content .login-notice {
  color: #4caf50;
}
.login-form .phase-content .login-error {
  color: #e53935;
}
.login-form .phaseless-content {
  padding: 0 30px;
}
    </style>
    <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <div class=body>
      <header class="header main-1" id=header>
        <div class=main-selector tabindex=-1 id=main-selector>
          <nav class=target>
            <img src="logo.svg" class="icon">
            <i class="fas fa-chevron-down"></i>
          </nav>
          <div class=options>
            <nav class="option open">Home</nav>
            <nav class=option>Multiplayer</nav>
            <nav class=option>Land</nav>
          </div>
        </div>

        <div class=channel-select>
          <div class=channels-content id=channels-content style="display: none"></div>
          <input type=text placeholder="channel name" id=channel-input>
          <div class=multibutton>
            <nav class="button first last" disabled id=connect-button>Create</nav>
            <nav class="button first last" id=disconnect-button style="display: none">Disconnect</nav>
          </div>
        </div>

        <div class=parcel-display>
          <div class=parcel-create id=parcel-create>
            <div class=multibutton>
              <nav class="button first last" id=create-parcel-button>Claim parcel</nav>
            </div>
          </div>
          <div class=parcel-edit id=parcel-edit>
            <input type=text placeholder="parcel name" id=parcel-name-input>
            <div class=multibutton>
              <nav class="button first last" id=save-parcel-button style="display: none">Save</nav>
            </div>
            <div class=multibutton>
              <nav class="button first last" id=edit-parcel-button>Edit parcel</nav>
            </div>
            <div class=multibutton>
              <nav class="button first last" id=stop-editing-button style="display: none">Stop editing</nav>
            </div>
          </div>
        </div>

        <!-- <form class="login-form phase-1" id=login-form>
          <div class=phase-content>
            <div class=login-notice id=login-notice></div>
            <div class=login-error id=login-error></div>
          </div>
          <div class="phase-content phase-1-content">
            <input type=email placeholder="your@email.com" id=login-email>
            <input type=submit value="Log in" class="button highlight">
          </div>
          <div class="phase-content phase-2-content">
            <input type=text placeholder="Verification code" id=login-verification-code>
            <input type=submit value="Verify" class="button highlight">
          </div>
          <div class="phase-content phase-3-content">
            <button class=user-button id=user-button>
              <img src="exobot.png">
              <span class=name id=login-email-static>a@modules.io</span>
            </button>
            <input type=submit value="Log out" class="button highlight">
          </div>
          <div class="phase-content phaseless-content">
            <div>Working...</div>
          </div>
        </form> -->
      </header>

      <div class=iframe-wrapper id=iframe-wrapper></div>
      <!-- <div class=tools>
        <nav class="tool open"><i class="fal fa-video"></i></nav>
        <nav class=tool><i class="fal fa-mouse-pointer"></i></nav>
        <nav class=tool><i class="fal fa-arrows"></i></nav>
        <nav class=tool><i class="fal fa-vector-square"></i></nav>
      </div> -->
      <form class=chat id=chat>
        <div class=messages id=chat-messages></div>
        <input type=text class=input id=chat-input>
      </form>
      <form class=save-dialog id=save-dialog>
        <input type=text placeholder="Enter file name..." id=save-name-input>
        <input type=submit value="Save">
      </form>
      <!-- <div class="iframe-buttons multibutton">
        <a class="button first" id="enable-mic-button">Enable Mic</a>
        <a class="button first" id="disable-mic-button" disabled style="display: none;">Disable Mic</a>
        <a class="button" id="firstperson-button">Firstperson</a>
        <a class="button" id="thirdperson-button">Thirdperson</a>
        <a class="button last" id="enter-xr-button" style="display: none;">Enter XR</a>
        <a class="button last" id="no-xr-button" disabled style="display: none;">No XR</a>
      </div> -->

      <div class=sidebar>
        <label class="switch-wrap on" id=gpu-switch-wrap>
          <div class=switch id=gpu-switch></div>
          GPU pointcloud
        </label>
        <label class=switch-wrap id=cpu-switch-wrap>
          <div class=switch id=cpu-switch></div>
          CPU pointcloud
        </label>
        <label class=switch-wrap id=raycast-switch-wrap>
          <div class=switch id=raycast-switch></div>
          Raycast
        </label>
        <label class=switch-wrap id=voxels-switch-wrap>
          <div class=switch id=voxels-switch></div>
          Voxelization
        </label>
        <label class=switch-wrap id=voxel-texture-switch-wrap>
          <div class=switch id=voxel-texture-switch></div>
          Voxel texture
        </label>
        <label class="switch-wrap on" id=meshing-switch-wrap>
          <div class=switch id=meshing-switch></div>
          Meshing
        </label>
        <label class=switch-wrap id=meshing-texture-switch-wrap>
          <div class=switch id=meshing-texture-switch></div>
          Mesh texture
        </label>
      </div>
    </div>
    <script type=module>
import './three.js';
// import './BufferGeometryUtils.js';
// import './OutlineEffect.js';
import './OrbitControls.js';
// import './TransformControls.js';
import './Reflector.js';
// import './land.js';
// import './bmfont.js';

import ModelLoader from 'https://model-loader.exokit.org/model-loader.js';
import avatarModels from 'https://avatar-models.exokit.org/avatar-models.js';

const worker = (() => {
  let cbs = [];
  const worker = new Worker('mc-worker.js');
  worker.onmessage = e => {
    const {data} = e;
    const {error, result} = data;
    cbs.shift()(error, result);
  };
  worker.onerror = err => {
    console.warn(err);
  };
  worker.request = (req, transfers) => new Promise((accept, reject) => {
    worker.postMessage(req, transfers);

    cbs.push((err, result) => {
      if (!err) {
        accept(result);
      } else {
        reject(err);
      }
    });
  });
  return worker;
})();

const parcelSize = 16;

const floorPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0));

const localVector = new THREE.Vector3();
const localVector2 = new THREE.Vector3();
const localVector3 = new THREE.Vector3();
const localVector4 = new THREE.Vector3();
const localVector5 = new THREE.Vector3();
const localVector2D = new THREE.Vector2();
const localQuaternion = new THREE.Quaternion();
const localQuaternion2 = new THREE.Quaternion();
const localMatrix = new THREE.Matrix4();
const localEuler = new THREE.Euler();
const localRaycaster = new THREE.Raycaster();
const localColor = new THREE.Color();

const z180Quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);

const scene = new THREE.Scene();

// renderItems(scene);

const container = new THREE.Object3D();
scene.add(container);

const fov_y = 60;
const aspect = window.innerWidth / window.innerHeight;
const orthoDepth = 3;
const height_ortho = orthoDepth * 2 * Math.atan( fov_y*(Math.PI/180) / 2 );
const width_ortho  = height_ortho * aspect;
const camera = new THREE.PerspectiveCamera(fov_y, aspect, 0.1, 1000);
camera.position.y = 1.5;
camera.position.z = 0.5;
// camera.lookAt(new THREE.Vector3(0, 1, 0))

const cursorCamera = new THREE.OrthographicCamera(
  width_ortho  / -2, width_ortho   /  2,
  height_ortho /  2, height_ortho  / -2,
  0.1, 300
);
const raycastCamera = cursorCamera.clone();

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight.position.set(0.5, 1, 0.5);
scene.add(directionalLight);

/* const directionalLight2 = new THREE.DirectionalLight(0xFFFFFF, 4);
directionalLight2.position.set(-0.5, 1, -0.5);
scene.add(directionalLight2); */

function mod(a, n) {
  return ((a%n)+n)%n;
}
const floorMesh = (() => {
  const numTiles = 64;
  const numTiles2P1 = 2*numTiles+1;
  const planeBufferGeometry = new THREE.PlaneBufferGeometry(1, 1)
    .applyMatrix(localMatrix.makeScale(0.95, 0.95, 1))
    .applyMatrix(localMatrix.makeRotationFromQuaternion(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI/2)))
    .toNonIndexed();
  const numCoords = planeBufferGeometry.attributes.position.array.length;
  const numVerts = numCoords/3;
  const positions = new Float32Array(numCoords*numTiles2P1*numTiles2P1);
  const typesx = new Float32Array(numVerts*numTiles2P1*numTiles2P1);
  const typesz = new Float32Array(numVerts*numTiles2P1*numTiles2P1);
  let i = 0;
  for (let x = -numTiles; x <= numTiles; x++) {
    for (let z = -numTiles; z <= numTiles; z++) {
      const newPlaneBufferGeometry = planeBufferGeometry.clone()
        .applyMatrix(localMatrix.makeTranslation(x, 0, z));
      positions.set(newPlaneBufferGeometry.attributes.position.array, i * newPlaneBufferGeometry.attributes.position.array.length);
      let typex = 0;
      if (mod((x + parcelSize/2), parcelSize) === 0) {
        typex = 1/8;
      } else if (mod((x + parcelSize/2), parcelSize) === parcelSize-1) {
        typex = 2/8;
      }
      let typez = 0;
      if (mod((z + parcelSize/2), parcelSize) === 0) {
        typez = 1/8;
      } else if (mod((z + parcelSize/2), parcelSize) === parcelSize-1) {
        typez = 2/8;
      }
      for (let j = 0; j < numVerts; j++) {
        typesx[i*numVerts + j] = typex;
        typesz[i*numVerts + j] = typez;
      }
      i++;
    }
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('typex', new THREE.BufferAttribute(typesx, 1));
  geometry.setAttribute('typez', new THREE.BufferAttribute(typesz, 1));
  const floorVsh = `
    // uniform float uAnimation;
    attribute float typex;
    attribute float typez;
    varying vec3 vPosition;
    varying float vTypex;
    varying float vTypez;
    varying float vDepth;
    void main() {
      // float radius = sqrt(position.x*position.x + position.z*position.z);
      vec3 p = vec3(position.x, position.y /*- (1.0 - uAnimation) * radius*/, position.z);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
      vPosition = position + vec3(0.5, 0.0, 0.5);
      vTypex = typex;
      vTypez = typez;
      vDepth = gl_Position.z / ${numTiles.toFixed(8)};
    }
  `;
  const floorFsh = `
    uniform vec4 uCurrentParcel;
    uniform vec4 uHoverParcel;
    uniform vec4 uSelectedParcel;
    uniform vec3 uSelectedColor;
    // uniform float uAnimation;
    varying vec3 vPosition;
    varying float vTypex;
    varying float vTypez;
    varying float vDepth;
    void main() {
      vec3 c;
      float a;
      if (
        vPosition.x >= uSelectedParcel.x &&
        vPosition.z >= uSelectedParcel.y &&
        vPosition.x <= uSelectedParcel.z &&
        vPosition.z <= uSelectedParcel.w
      ) {
        c = uSelectedColor;
      } else {
        c = vec3(0.5);
      }
      float add = 0.0;
      if (
        vPosition.x >= uHoverParcel.x &&
        vPosition.z >= uHoverParcel.y &&
        vPosition.x <= uHoverParcel.z &&
        vPosition.z <= uHoverParcel.w
      ) {
        add = 0.2;
      } else {
        vec3 f = fract(vPosition);
        if (vTypex >= 2.0/8.0) {
          if (f.x >= 0.8) {
            add = 0.2;
          }
        } else if (vTypex >= 1.0/8.0) {
          if (f.x <= 0.2) {
            add = 0.2;
          }
        }
        if (vTypez >= 2.0/8.0) {
          if (f.z >= 0.8) {
            add = 0.2;
          }
        } else if (vTypez >= 1.0/8.0) {
          if (f.z <= 0.2) {
            add = 0.2;
          }
        }
        /* if (
          vPosition.x >= uCurrentParcel.x &&
          vPosition.z >= uCurrentParcel.y &&
          vPosition.x <= uCurrentParcel.z &&
          vPosition.z <= uCurrentParcel.w
        ) {
          add = 0.2;
        } */
      }
      c += add;
      a = (1.0-vDepth)*0.5;
      gl_FragColor = vec4(c, a);
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      /* uTex: {
        type: 't',
        value: new THREE.Texture(),
      }, */
      uCurrentParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uHoverParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uSelectedParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uSelectedColor: {
        type: 'c',
        value: new THREE.Color().setHex(0x29b6f6),
      },
      uAnimation: {
        type: 'f',
        value: 1,
      },
    },
    vertexShader: floorVsh,
    fragmentShader: floorFsh,
    transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
container.add(floorMesh);

let renderingMirror = false;
const mirrorMesh = (() => {
  const mirrorWidth = 3;
  const mirrorHeight = 2;
  const geometry = new THREE.PlaneBufferGeometry(mirrorWidth, mirrorHeight)
    .applyMatrix(new THREE.Matrix4().makeTranslation(0, 1, 0));
  const mesh = new THREE.Reflector(geometry, {
    clipBias: 0.003,
    textureWidth: 1024 * window.devicePixelRatio,
    textureHeight: 2048 * window.devicePixelRatio,
    color: 0x889999,
    backgroundColor: 0x000000,
    recursion: 1,
    transparent: true,
  });
  mesh.position.set(0, 0, -1);

  const borderMesh = new THREE.Mesh(
    new THREE.BoxBufferGeometry(mirrorWidth + 0.1, mirrorHeight + 0.1, 0.1)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 1, -0.1/2 - 0.01)),
    new THREE.MeshPhongMaterial({
      color: 0x5c6bc0,
    })
  );
  mesh.add(borderMesh);

  mesh.onBeforeRender2 = () => {
    renderingMirror = true;
  };
  mesh.onAfterRender2 = () => {
    renderingMirror = false;
  };

  return mesh;
})();
// container.add(mirrorMesh);

const boxMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(2, 2, 0.1);
  const material = new THREE.MeshPhongMaterial({
    color: 0x333333,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
boxMesh.position.y = 1;
boxMesh.position.z = -1;
container.add(boxMesh);

(async () => {
  const {url} = avatarModels[0];
  const src = `https://avatar-models.exokit.org/${url}`;
  const object = await ModelLoader.loadModelUrl(src);
  const model = object.scene;
  model.position.x = 0.5;
  model.position.z = 0.5;
  container.add(model);
})();

const gpuSwitchWrap = document.getElementById('gpu-switch-wrap');
gpuSwitchWrap.addEventListener('click', () => {
  gpuSwitchWrap.classList.toggle('on');
  gpuParticlesMesh.visible = gpuSwitchWrap.classList.contains('on');
});
const cpuSwitchWrap = document.getElementById('cpu-switch-wrap');
cpuSwitchWrap.addEventListener('click', () => {
  cpuSwitchWrap.classList.toggle('on');
  particlesMesh.visible = cpuSwitchWrap.classList.contains('on');
});
const raycastSwitchWrap = document.getElementById('raycast-switch-wrap');
raycastSwitchWrap.addEventListener('click', () => {
  raycastSwitchWrap.classList.toggle('on');
  raycastMesh.visible = raycastSwitchWrap.classList.contains('on');
});
const voxelsSwitchWrap = document.getElementById('voxels-switch-wrap');
voxelsSwitchWrap.addEventListener('click', () => {
  voxelsSwitchWrap.classList.toggle('on');
  voxelsMesh.visible = voxelsSwitchWrap.classList.contains('on');
});
const voxelTextureSwitchWrap = document.getElementById('voxel-texture-switch-wrap');
voxelTextureSwitchWrap.addEventListener('click', () => {
  voxelTextureSwitchWrap.classList.toggle('on');
  voxelsMesh.material = voxelTextureSwitchWrap.classList.contains('on') ? voxelsTexturedMaterial : voxelsMaterial;
});
const meshingSwitchWrap = document.getElementById('meshing-switch-wrap');
meshingSwitchWrap.addEventListener('click', () => {
  meshingSwitchWrap.classList.toggle('on');
  marchCubesMesh.visible = meshingSwitchWrap.classList.contains('on');
});
const meshingTextureSwitchWrap = document.getElementById('meshing-texture-switch-wrap');
meshingTextureSwitchWrap.addEventListener('click', () => {
  meshingTextureSwitchWrap.classList.toggle('on');
  const enabled = meshingTextureSwitchWrap.classList.contains('on');
  marchCubesMesh.material = enabled ? marchCubesTexturedMaterial : marchCubesMaterial;
});

const renderer = new THREE.WebGLRenderer({
  alpha: true,
  antialias: true,
});
// console.log('set size', window.innerWidth, window.innerHeight);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.sortObjects = false;
renderer.getContext().canvas.addEventListener('webglcontextlost', e => {
  console.log('webglcontextlost', e);
  debugger;
});
const iframeWrapper = document.getElementById('iframe-wrapper');
iframeWrapper.appendChild(renderer.domElement);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
orbitControls.target.set(0, 1, 0);
orbitControls.screenSpacePanning = true;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const _makeRenderTargetPlaneMesh = map => {
  const geometry = new THREE.PlaneBufferGeometry(0.5, 0.5);
  const material = new THREE.MeshBasicMaterial({
    map,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
};

const colorTargetSize = 256;
const colorTarget = new THREE.WebGLRenderTarget(colorTargetSize, colorTargetSize, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.NearestFilter,
  format: THREE.RGBAFormat,
  type: THREE.FloatType,
  depthBuffer: true,
  stencilBuffer: false,
});

const raycastTarget = new THREE.WebGLRenderTarget(1, 1, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.NearestFilter,
  format: THREE.RGBAFormat,
  type: THREE.FloatType,
  depthBuffer: true,
  stencilBuffer: false,
});

const raycastMesh = (() => {
  const geometry = new THREE.BoxBufferGeometry(0.05, 0.05, 0.05);
  const material = new THREE.MeshPhongMaterial({
    color: 0xFF0000,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  return mesh;
})();
raycastMesh.visible = raycastSwitchWrap.classList.contains('on');
container.add(raycastMesh);

const particlesMesh = (() => {
  const resolutionP1 = colorTargetSize + 1;
  const cubeGeometry = new THREE.BoxBufferGeometry(0.01, 0.01, 0.01).toNonIndexed();
  const positions = new Float32Array(cubeGeometry.attributes.position.array.length*resolutionP1*resolutionP1);
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const material = new THREE.MeshBasicMaterial({
    color: 0x00FFFF,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    cursorCamera.position.copy(camera.position);
    cursorCamera.quaternion.copy(camera.quaternion);
    _renderDepth(colorTarget, cursorCamera);

    const pbuf = new Float32Array(colorTarget.width*colorTarget.height*4);
    renderer.readRenderTargetPixels(colorTarget, 0, 0, colorTarget.width, colorTarget.height, pbuf, 0);

    let i = 0;
    for (let x = 0; x < colorTargetSize; x++) {
      for (let y = 0; y < colorTargetSize; y++) {
        // console.log(i);
        const xFactor = x / colorTargetSize;
        const yFactor = y / colorTargetSize;
        const px = Math.floor(xFactor * colorTarget.width);
        const py = Math.floor((1-yFactor) * colorTarget.height);
        const z = DecodeFloatRGBA(pbuf, (px * 4) + (py * colorTarget.width * 4));
        
        localRaycaster.setFromCamera(localVector2D.set(xFactor * 2 - 1, -yFactor * 2 + 1), cursorCamera);
        localVector.copy(localRaycaster.ray.origin)
          .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(z));
        const newCubeGeometry = cubeGeometry.clone()
          .applyMatrix(localMatrix.makeTranslation(localVector.x, localVector.y, localVector.z));
        positions.set(newCubeGeometry.attributes.position.array, i*newCubeGeometry.attributes.position.array.length);
        i++;
      }
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  };
  return mesh;
})();
particlesMesh.visible = cpuSwitchWrap.classList.contains('on');
container.add(particlesMesh);

const gpuParticlesMeshMaterial = (() => {
  const depthVsh = `
    // uniform float uAnimation;
    // attribute float typex;
    // varying vec3 vPosition;
    uniform mat4 uMatrixWorld;
    uniform mat4 uProjectionMatrixInverse;
    uniform vec3 uDirection;
    uniform sampler2D uDepthTex;
    uniform float uNear;
    uniform float uFar;
    float DecodeFloatRGBA( vec4 rgba ) {
      return dot( rgba, vec4(1.0, 255.0, 255.0*255.0, 255.0*255.0*255.0) );
    }
    void main() {
      float xFactor = uv.x;
      float yFactor = uv.y;
      float z = DecodeFloatRGBA(texture2D(uDepthTex, vec2(xFactor, 1.0-yFactor)));

      vec2 coords = vec2(xFactor * 2. - 1., -yFactor * 2. + 1.);
      vec3 origin = (uMatrixWorld * uProjectionMatrixInverse * vec4(coords.x, coords.y, ( uNear + uFar ) / ( uNear - uFar ), 1.0)).xyz;
      vec3 direction = uDirection;

      vec3 p = position + origin + direction * z;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.);
    }
  `;
  const depthFsh = `
    vec4 EncodeFloatRGBA( float v ) {
      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
      enc = fract(enc);
      // enc -= enc.xyzw * vec4(1.0/255.0,1.0/255.0,1.0/255.0,1.0/255.0);
      return enc;
    }
    // const float infinity = 1./0.;
    void main() {
      gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    }
  `;
  return new THREE.ShaderMaterial({
    uniforms: {
      uMatrixWorld: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
      uProjectionMatrixInverse: {
        type: 'm4',
        value: new THREE.Matrix4(),
      },
      uDirection: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uNear: {
        type: 'f',
        value: 0,
      },
      uFar: {
        type: 'f',
        value: 1,
      },
      uDepthTex: {
        type: 't',
        value: null,
      },
    },
    vertexShader: depthVsh,
    fragmentShader: depthFsh,
    // transparent: true,
  });
})();
const gpuParticlesMesh = (() => {
  const resolutionP1 = colorTargetSize + 1;
  const cubeGeometry = new THREE.BoxBufferGeometry(0.01, 0.01, 0.01).toNonIndexed();
  const positions = new Float32Array(cubeGeometry.attributes.position.array.length*resolutionP1*resolutionP1);
  const numVecs = cubeGeometry.attributes.position.array.length/3;
  const uvs = new Float32Array(numVecs*2*resolutionP1*resolutionP1);

  let i = 0;
  for (let x = 0; x < colorTargetSize; x++) {
    for (let y = 0; y < colorTargetSize; y++) {
      const xFactor = x / colorTargetSize;
      const yFactor = y / colorTargetSize;
      /* const px = Math.floor(xFactor * colorTarget.width);
      const py = Math.floor((1-yFactor) * colorTarget.height);
      const z = DecodeFloatRGBA(pbuf, (px * 4) + (py * colorTarget.width * 4));
      
      localRaycaster.setFromCamera(localVector2D.set(xFactor * 2 - 1, -yFactor * 2 + 1), cursorCamera);
      localVector.copy(localRaycaster.ray.origin)
        .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(z)); */
      positions.set(cubeGeometry.attributes.position.array, i*cubeGeometry.attributes.position.array.length);
      for (let j = 0; j < numVecs; j++) {
        /* if (j === 10) {
          console.log('set uv', i*numVecs*2 + j*2, xFactor, yFactor);
        } */
        uvs[i*numVecs*2 + j*2] = xFactor;
        uvs[i*numVecs*2 + j*2 + 1] = yFactor;
      }
      i++;
    }
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
  const material = gpuParticlesMeshMaterial;
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    cursorCamera.position.copy(camera.position);
    cursorCamera.quaternion.copy(camera.quaternion);
    cursorCamera.updateMatrixWorld();
    _renderDepth(colorTarget, cursorCamera);

    gpuParticlesMeshMaterial.uniforms.uMatrixWorld.value.copy(cursorCamera.matrixWorld);
    gpuParticlesMeshMaterial.uniforms.uProjectionMatrixInverse.value.copy(cursorCamera.projectionMatrixInverse);
    gpuParticlesMeshMaterial.uniforms.uDirection.value.set(0, 0, -1).transformDirection(cursorCamera.matrixWorld);
    gpuParticlesMeshMaterial.uniforms.uNear.value = cursorCamera.near;
    gpuParticlesMeshMaterial.uniforms.uFar.value = cursorCamera.far;
    gpuParticlesMeshMaterial.uniforms.uDepthTex.value = colorTarget.texture;
  };
  return mesh;
})();
gpuParticlesMesh.visible = gpuSwitchWrap.classList.contains('on');
container.add(gpuParticlesMesh);

const depthMaterial = (() => {
  const depthVsh = `
    // uniform float uAnimation;
    // attribute float typex;
    // varying vec3 vPosition;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    }
  `;
  const depthFsh = `
    vec4 EncodeFloatRGBA( float v ) {
      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;
      enc = fract(enc);
      // enc -= enc.xyzw * vec4(1.0/255.0,1.0/255.0,1.0/255.0,1.0/255.0);
      return enc;
    }
    /* float DecodeFloatRGBA( vec4 rgba ) {
      return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
    } */
    // const float infinity = 1./0.;
    void main() {
      float originalZ = ${cursorCamera.near.toFixed(8)} + gl_FragCoord.z / gl_FragCoord.w * ${(cursorCamera.far - cursorCamera.near).toFixed(8)};
      // gl_FragColor = EncodeFloatRGBA(originalZ);

      float x = fract(originalZ);
      originalZ -= x;
      originalZ /= 255.0;
      float y = fract(originalZ);
      originalZ -= y;
      originalZ /= 255.0;
      float z = fract(originalZ);
      /* originalZ -= y;
      originalZ /= 255.0;
      float w = fract(originalZ);
      float w = 0.0;
      if (x == 0.0 && y == 0.0 && z == 0.0 && w == 0.0) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
      } else { */
        gl_FragColor = vec4(x, y, z, 0.0);
      // }
    }
  `;
  return new THREE.ShaderMaterial({
    uniforms: {
      /* uCurrentParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uHoverParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uSelectedParcel: {
        type: 'v4',
        value: new THREE.Vector4(),
      },
      uSelectedColor: {
        type: 'c',
        value: new THREE.Color().setHex(0x29b6f6),
      },
      uAnimation: {
        type: 'f',
        value: 1,
      }, */
    },
    vertexShader: depthVsh,
    fragmentShader: depthFsh,
    // transparent: true,
  });
})();

const cameraSize = 512;
const cameraTarget = new THREE.WebGLRenderTarget(cameraSize, cameraSize, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.NearestFilter,
  format: THREE.RGBAFormat,
  // type: THREE.FloatType,
  depthBuffer: true,
  stencilBuffer: false,
});

const width = 20;
const height = 20;
const depth = 20;
const voxelSize = 0.1;
const potentialClearValue = -0.2;
const potentialSetValue = 0.7;
const potentials = new Float32Array(width*height*depth);
const potentialsTexture = new THREE.DataTexture(potentials, width*height*depth, 1, THREE.LuminanceFormat, THREE.FloatType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
const workingPotentials = new Float32Array(width*height*depth);
const voxelsMaterial = (() => {
  const voxelsVsh = `
    attribute vec3 pos;
    uniform sampler2D uPotentialsTex;
    varying float vPotential;
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);

      float ux = (pos.x + pos.y*${(width*depth).toFixed(8)} + pos.z*${(width).toFixed(8)} + 0.5) / ${(width*height*depth).toFixed(8)};
      vec2 uv = vec2(ux, 0.5);
      vPotential = texture2D(uPotentialsTex, uv).r;
    }
  `;
  const voxelsFsh = `
    varying float vPotential;

    vec3 color = vec3(0.984313725490196, 0.5490196078431373, 0.0);

    void main() {
      if (vPotential > 0.0) {
        gl_FragColor = vec4(color, vPotential);
      } else {
        discard;
      }
    }
  `;
  return new THREE.ShaderMaterial({
    uniforms: {
      uPotentialsTex: {
        type: 't',
        value: potentialsTexture,
      },
    },
    vertexShader: voxelsVsh,
    fragmentShader: voxelsFsh,
    transparent: true,
    depthWrite: false,
  });
})();
const voxelsTexturedMaterial = (() => {
  const voxelsVsh = `
    attribute vec3 pos;
    attribute vec3 positionCenter;
    uniform sampler2D uPotentialsTex;
    uniform sampler2D uCameraTex;
    varying float vPotential;
    varying vec3 vPosition;
    varying vec4 vColor;
    void main() {
      float ux = (pos.x + pos.y*${(width*depth).toFixed(8)} + pos.z*${(width).toFixed(8)} + 0.5) / ${(width*height*depth).toFixed(8)};
      vec2 voxelUv = vec2(ux, 0.5);
      vPotential = texture2D(uPotentialsTex, voxelUv).r;

      vec4 projectionPositionCenter = projectionMatrix * modelViewMatrix * vec4(positionCenter, 1.0);
      vec3 screenPosition = (projectionPositionCenter.xyz/projectionPositionCenter.w)/2.0+0.5;
      vec2 uv = screenPosition.xy;
      vColor = texture2D(uCameraTex, uv);
      // vColor = vec4(1.0, 0.0, 1.0, 1.0);

      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      vPosition = modelViewPosition.xyz;
      gl_Position = projectionMatrix * modelViewPosition;
    }
  `;
  const voxelsFsh = `
    uniform sampler2D uCameraTex;
    varying float vPotential;
    varying vec3 vPosition;
    varying vec4 vColor;

    vec3 lightDirection = vec3(0.0, 0.0, 1.0);

    void main() {
      if (vPotential > 0.0) {
        /* gl_FragColor = vec4(vec3(${localColor.setHex(0xef5350).toArray().join(', ')}), 0.2 + vPotential);
        gl_FragColor = vec4(vec3(1.0), 0.1);
        vec2 uv = vScreenPosition.xy;
        gl_FragColor = texture2D(uCameraTex, uv); */

        vec3 xTangent = dFdx( vPosition );
        vec3 yTangent = dFdy( vPosition );
        vec3 faceNormal = normalize( cross( xTangent, yTangent ) );
        float lightFactor = dot(faceNormal, lightDirection);

        gl_FragColor = vColor * lightFactor;
        gl_FragColor.a = 1.0;
      } else {
        discard;
      }
    }
  `;
  return new THREE.ShaderMaterial({
    uniforms: {
      uPotentialsTex: {
        type: 't',
        value: potentialsTexture,
      },
      uCameraTex: {
        type: 't',
        value: cameraTarget.texture,
      },
    },
    vertexShader: voxelsVsh,
    fragmentShader: voxelsFsh,
    // transparent: true,
    extensions: {
      derivatives: true,
    },
  });
})();

const _getPotentialIndex = (x, y, z) => x + y*width*depth + z*width;
const voxelsMesh = (() => {
  const cubeGeometry = new THREE.BoxBufferGeometry(voxelSize, voxelSize, voxelSize)
    // .applyMatrix(localMatrix.makeTranslation(voxelSize/2, voxelSize/2, voxelSize/2))
    .toNonIndexed();
  const positions = new Float32Array(cubeGeometry.attributes.position.array.length*width*height*depth);
  const poss = new Float32Array(cubeGeometry.attributes.position.array.length*width*height*depth);
  const positionCenters = new Float32Array(cubeGeometry.attributes.position.array.length*width*height*depth);
  let i = 0;
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      for (let z = 0; z < depth; z++) {
        const newCubeGeometry = cubeGeometry.clone()
          .applyMatrix(localMatrix.makeTranslation(x*voxelSize, y*voxelSize, z*voxelSize));
        positions.set(newCubeGeometry.attributes.position.array, i*newCubeGeometry.attributes.position.array.length);
        const offset = Float32Array.from([x, y, z]);
        for (let j = 0; j < newCubeGeometry.attributes.position.array.length/3; j++) {
          poss.set(offset, i*newCubeGeometry.attributes.position.array.length + j*3);
        }
        const center = Float32Array.from([x*voxelSize + 0.5*voxelSize, y*voxelSize + 0.5*voxelSize, z*voxelSize + 0.5*voxelSize]);
        for (let j = 0; j < newCubeGeometry.attributes.position.array.length/3; j++) {
          positionCenters.set(center, i*newCubeGeometry.attributes.position.array.length + j*3);
        }
        i++;
      }
    }
  }
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('pos', new THREE.BufferAttribute(poss, 3));
  geometry.setAttribute('positionCenter', new THREE.BufferAttribute(positionCenters, 3));
  const material = voxelTextureSwitchWrap.classList.contains('on') ? voxelsTexturedMaterial : voxelsMaterial;
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.update = () => {
    cursorCamera.position.copy(camera.position);
    cursorCamera.quaternion.copy(camera.quaternion);
    _renderDepth(colorTarget, cursorCamera);

    const pbuf = new Float32Array(colorTarget.width*colorTarget.height*4);
    renderer.readRenderTargetPixels(colorTarget, 0, 0, colorTarget.width, colorTarget.height, pbuf, 0);

    workingPotentials.fill(potentialClearValue);
    let i = 0;
    for (let x = 0; x < colorTargetSize; x++) {
      for (let y = 0; y < colorTargetSize; y++) {
        // console.log(i);
        const xFactor = x / colorTargetSize;
        const yFactor = y / colorTargetSize;
        const px = Math.floor(xFactor * colorTarget.width);
        const py = Math.floor((1-yFactor) * colorTarget.height);
        const z = DecodeFloatRGBA(pbuf, (px * 4) + (py * colorTarget.width * 4));
        
        localRaycaster.setFromCamera(localVector2D.set(xFactor * 2 - 1, -yFactor * 2 + 1), cursorCamera);
        localVector.copy(localRaycaster.ray.origin)
          .add(localVector2.copy(localRaycaster.ray.direction).multiplyScalar(z));

        if (
          localVector.x >= 0 && localVector.x <= width * voxelSize &&
          localVector.y >= 0 && localVector.y <= height * voxelSize &&
          localVector.z >= 0 && localVector.z <= depth * voxelSize
        ) {
          workingPotentials[_getPotentialIndex(
            Math.floor(localVector.x/voxelSize + 0.5),
            Math.floor(localVector.y/voxelSize + 0.5),
            Math.floor(localVector.z/voxelSize + 0.5)
          )] = potentialSetValue;
        }
        i++;
      }
    }
    for (let x = 0; x < width; x++) {
      for (let y = 0; y < height; y++) {
        for (let z = 0; z < depth; z++) {
          let sum = 0;
          let num = 0;
          for (let dx = -1; dx <= 1; dx++) {
            const ax = x + dx;
            if (ax >= 0 && ax < width) {
              for (let dy = -1; dy <= 1; dy++) {
                const ay = y + dy;
                if (ay >= 0 && ay < height) {
                  for (let dz = -1; dz <= 1; dz++) {
                    const az = z + dz;
                    if (az >= 0 && az < depth) {
                      sum += workingPotentials[_getPotentialIndex(ax, ay, az)];
                      num++;
                    }
                  }
                }
              }
            }
          }
          potentials[_getPotentialIndex(x, y, z)] = sum/num;
        }
      }
    }
    potentialsTexture.needsUpdate = true;
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  };
  return mesh;
})();
voxelsMesh.visible = voxelsSwitchWrap.classList.contains('on');
container.add(voxelsMesh);

const marchCubesTexSize = 4096;
const marchCubesTexTriangleSize = 128;
const marchCubesTexSquares = marchCubesTexSize/marchCubesTexTriangleSize;
const marchCubesRenderTarget = new THREE.WebGLRenderTarget(marchCubesTexSize, marchCubesTexSize, {
  minFilter: THREE.LinearFilter,
  magFilter: THREE.NearestFilter,
  format: THREE.RGBAFormat,
  // type: THREE.FloatType,
  depthBuffer: true,
  stencilBuffer: false,
});

const marchCubesMaterial = new THREE.ShaderMaterial({
  uniforms: {},
  vertexShader: `\
    attribute vec3 barycentric;
    varying vec3 vPosition;
    varying vec3 vBC;
    void main() {
      vBC = barycentric;
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      vPosition = modelViewPosition.xyz;
      gl_Position = projectionMatrix * modelViewPosition;
    }
  `,
  fragmentShader: `\
    uniform sampler2D uCameraTex;
    varying vec3 vPosition;
    varying vec3 vBC;

    vec3 color = vec3(0.984313725490196, 0.5490196078431373, 0.0);
    vec3 lightDirection = vec3(0.0, 0.0, 1.0);

    float edgeFactor() {
      vec3 d = fwidth(vBC);
      vec3 a3 = smoothstep(vec3(0.0), d*1.5, vBC);
      return min(min(a3.x, a3.y), a3.z);
    }

    void main() {
      float barycentricFactor = (0.2 + (1.0 - edgeFactor()) * 0.8);
      vec3 xTangent = dFdx( vPosition );
      vec3 yTangent = dFdy( vPosition );
      vec3 faceNormal = normalize( cross( xTangent, yTangent ) );
      float lightFactor = dot(faceNormal, lightDirection);
      gl_FragColor = vec4((0.5 + color * barycentricFactor) * lightFactor, 0.9 * barycentricFactor);
    }
  `,
  side: THREE.BackSide,
  /* polygonOffset: true,
  polygonOffsetFactor: -1,
  polygonOffsetUnits: -4, */
  transparent: true,
  extensions: {
    derivatives: true,
  },
});
const marchCubesTexturedMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uMarchCubesTex: {
      type: 't',
      value: marchCubesRenderTarget.texture,
    },
  },
  vertexShader: `\
    attribute vec3 barycentric;
    varying vec2 vUv;
    void main() {
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      gl_Position = projectionMatrix * modelViewPosition;
      vUv = uv;
    }
  `,
  fragmentShader: `\
    uniform sampler2D uMarchCubesTex;
    varying vec2 vUv;

    void main() {
      gl_FragColor = texture2D(uMarchCubesTex, vUv);
      gl_FragColor.rgb += 0.2;
      gl_FragColor.a = 1.0;
    }
  `,
  side: THREE.BackSide,
  /* polygonOffset: true,
  polygonOffsetFactor: -1,
  polygonOffsetUnits: -4, */
  transparent: true,
});
const marchCubesRenderMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uCameraTex: {
      type: 't',
      value: cameraTarget.texture,
    },
  },
  vertexShader: `\
    varying vec3 vScreenPosition;
    void main() {
      gl_Position = vec4((uv-0.5)*2.0, 0.0, 1.0);
      vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
      vec4 projectionPosition = projectionMatrix * modelViewPosition;
      vScreenPosition = (projectionPosition.xyz/projectionPosition.w)/2.0+0.5;
    }
  `,
  fragmentShader: `\
    uniform sampler2D uCameraTex;
    varying vec3 vScreenPosition;

    void main() {
      vec2 uv = vScreenPosition.xy;
      gl_FragColor = texture2D(uCameraTex, uv);
      gl_FragColor.a = 1.0;
    }
  `,
  side: THREE.BackSide,
  /* polygonOffset: true,
  polygonOffsetFactor: -1,
  polygonOffsetUnits: -4, */
  transparent: true,
  extensions: {
    derivatives: true,
  },
});
const marchCubesMesh = (() => {
  const geometry = new THREE.BufferGeometry();
  const material = meshingTextureSwitchWrap.classList.contains('on') ? marchCubesTexturedMaterial : marchCubesMaterial;
  const mesh = new THREE.Mesh(geometry, material);
  mesh.scale.set(1, 1, 1).multiplyScalar(voxelSize);
  mesh.frustumCulled = false;
  mesh.visible = false;
  let running = false;
  mesh.update = () => {
    if (!running) {
      running = true;
      worker.request({
        method: 'march',
        dims: Float32Array.from([width, height, depth]),
        potential: potentials,
        shift: Float32Array.from([0, 0, 0]),
      }).then(res => {
        if (res.positions.length > 0) {
          const positionArray = res.positions;
          const indexArray = res.faces;

          const positions = new Float32Array(indexArray.length*3);
          const barycentrics = new Float32Array(indexArray.length*3);
          const uvs = new Float32Array(indexArray.length*2);
          for (let i = 0; i < indexArray.length; i += 3) {
            const ai = indexArray[i];
            const bi = indexArray[i+1];
            const ci = indexArray[i+2];

            const baseA = ai*3;
            const baseB = bi*3;
            const baseC = ci*3;

            const baseIndex = i*3;
            positions[baseIndex] = positionArray[baseA];
            positions[baseIndex+1] = positionArray[baseA+1];
            positions[baseIndex+2] = positionArray[baseA+2];
            positions[baseIndex+3] = positionArray[baseB];
            positions[baseIndex+4] = positionArray[baseB+1];
            positions[baseIndex+5] = positionArray[baseB+2];
            positions[baseIndex+6] = positionArray[baseC];
            positions[baseIndex+7] = positionArray[baseC+1];
            positions[baseIndex+8] = positionArray[baseC+2];

            barycentrics[baseIndex] = 1;
            barycentrics[baseIndex+1] = 0;
            barycentrics[baseIndex+2] = 0;
            barycentrics[baseIndex+3] = 0;
            barycentrics[baseIndex+4] = 1;
            barycentrics[baseIndex+5] = 0;
            barycentrics[baseIndex+6] = 0;
            barycentrics[baseIndex+7] = 0;
            barycentrics[baseIndex+8] = 1;

            const baseI = i/3;
            const baseIndex2 = i*2;
            if ((baseI%2) === 0) {
              const cx = (baseI/2)%(marchCubesTexSquares);
              const cy = Math.floor(baseI/2/(marchCubesTexSquares));
              uvs[baseIndex2] = cx*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+1] = cy*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+2] = cx*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+3] = (cy+1)*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+4] = (cx+1)*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+5] = (cy+1)*marchCubesTexTriangleSize/marchCubesTexSize;
            } else {
              const cx = ((baseI-1)/2)%(marchCubesTexSquares);
              const cy = Math.floor((baseI-1)/2/(marchCubesTexSquares));
              uvs[baseIndex2] = cx*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+1] = cy*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+2] = (cx+1)*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+3] = (cy+1)*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+4] = (cx+1)*marchCubesTexTriangleSize/marchCubesTexSize;
              uvs[baseIndex2+5] = cy*marchCubesTexTriangleSize/marchCubesTexSize;
            }
          }
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geometry.setAttribute('barycentric', new THREE.BufferAttribute(barycentrics, 3));
          geometry.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));

          mesh.visible = meshingSwitchWrap.classList.contains('on');
        } else {
          mesh.visible = false;
        }

        running = false;
      });
    }
  };
  return mesh;
})();
marchCubesMesh.visible = meshingSwitchWrap.classList.contains('on');
container.add(marchCubesMesh);

const marchCubesRenderMesh = (() => {
  const {geometry} = marchCubesMesh;
  const material = marchCubesRenderMaterial;
  const mesh = new THREE.Mesh(geometry, material);
  mesh.scale.copy(marchCubesMesh.scale);
  mesh.frustumCulled = false;
  return mesh;
})();
const marchCubesRenderScene = new THREE.Scene();
marchCubesRenderScene.add(marchCubesRenderMesh);

const testMesh = _makeRenderTargetPlaneMesh(marchCubesRenderTarget.texture);
testMesh.position.set(1, 1, 0);
scene.add(testMesh);

const pbuf = new Float32Array(4);
function DecodeFloatRGBA(rgba, i) {
  /* if (rgba[i] === 0 && rgba[i+1] === 0 && rgba[i+2] === 0 && rgba[3] === 0) {
    return Infinity;
  } else { */
    return rgba[i] +
      rgba[i+1] * 255.0 +
      rgba[i+2] * 255.0*255.0 +
      rgba[i+3] * 255.0*255.0*255.0;
    // return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );
  // }
}
window.addEventListener('mousemove', e => {
  if (raycastSwitchWrap.classList.contains('on')) {
    const rect = renderer.domElement.getBoundingClientRect();

    const xFactor = (e.clientX - rect.left) / rect.width;
    const yFactor = -(e.clientY - rect.top) / rect.height;
    if (xFactor >= 0 && xFactor <= 1 && -yFactor >= 0 && -yFactor <= 1) {
      localRaycaster.setFromCamera(localVector2D.set(xFactor * 2 - 1, yFactor * 2 + 1), camera);
      raycastCamera.position.copy(localRaycaster.ray.origin);
      raycastCamera.quaternion.setFromUnitVectors(localVector.set(0, 0, -1), localRaycaster.ray.direction);
      _renderDepth(raycastTarget, raycastCamera);

      renderer.readRenderTargetPixels(raycastTarget, 0, 0, 1, 1, pbuf, 0);
      const z = DecodeFloatRGBA(pbuf, 0);
      raycastMesh.position.copy(localRaycaster.ray.origin)
        .add(localVector.copy(localRaycaster.ray.direction).multiplyScalar(z));
      // console.log('read', z, raycastMesh.position.y, pbuf.join(','));
    }
  }
});

setInterval(() => {
  if (gpuSwitchWrap.classList.contains('on')) {
    gpuParticlesMesh.update();
  }
  if (cpuSwitchWrap.classList.contains('on')) {
    particlesMesh.update();
  }
  voxelsMesh.update();
  marchCubesMesh.update();
}, 100);

const _hideUiMeshes = () => {
  const oldRaycastMeshVisible = raycastMesh.visible;
  raycastMesh.visible = false;
  const oldParticlesMeshVisible = particlesMesh.visible;
  particlesMesh.visible = false;
  const oldGpuParticlesMeshVisible = gpuParticlesMesh.visible;
  gpuParticlesMesh.visible = false;
  const oldVoxelsMeshVisible = voxelsMesh.visible;
  voxelsMesh.visible = false;
  const oldMarchCubesMeshVisible = marchCubesMesh.visible;
  marchCubesMesh.visible = false;
  const oldTestMeshVisible = testMesh.visible;
  testMesh.visible = false;

  return () => {
    raycastMesh.visible = oldRaycastMeshVisible;
    particlesMesh.visible = oldParticlesMeshVisible;
    gpuParticlesMesh.visible = oldGpuParticlesMeshVisible;
    voxelsMesh.visible = oldVoxelsMeshVisible;
    marchCubesMesh.visible = oldMarchCubesMeshVisible;
    testMesh.visible = oldTestMeshVisible;
  };
};
const _renderDepth = (target, camera) => {
  const unhideUiMeshes = _hideUiMeshes();

  scene.overrideMaterial = depthMaterial;
  renderer.setRenderTarget(target);
  renderer.setClearColor(localColor.set(0, 0, 0), 1);
  renderer.render(scene, camera);
  scene.overrideMaterial = null;
  renderer.setClearColor(localColor.set(0, 0, 0), 0);

  unhideUiMeshes();

  renderer.setRenderTarget(null);
};
function animate(timestamp, frame, referenceSpace) {
  if (meshingTextureSwitchWrap.classList.contains('on') || voxelTextureSwitchWrap.classList.contains('on')) {
    const unhideUiMeshes = _hideUiMeshes();

    renderer.setRenderTarget(cameraTarget);
    renderer.render(scene, camera);

    if (meshingTextureSwitchWrap.classList.contains('on')) {
      renderer.setRenderTarget(marchCubesRenderTarget);
      renderer.render(marchCubesRenderScene, camera);
    }

    unhideUiMeshes();
  }

  renderer.setRenderTarget(null);
  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);
    </script>
  </body>
</html>
